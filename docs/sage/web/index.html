<!DOCTYPE html>

<html>

<head>
    <title>hello-wasm example</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"
        integrity="sha512-8RnEqURPUc5aqFEN04aQEiPlSAdE0jlFS/9iGgUyNtwFnSKCXhmB6ZTNl7LnDtDWKabJIASzXrzD0K+LYexU9g=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css"
        integrity="sha512-uf06llspW44/LZpHzHT6qBOIVODjWtv4MxCricRxkzvopAlSWnTf6hpZTFxuuZcuNE9CBQhqE0Seu1CoRk84nQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/mode/simple.min.js"
        integrity="sha512-CGM6DWPHs250F/m90YZ9NEiEUhd9a4+u8wAzeKC6uHzZbYyt9/e2dLC5BGGB6Y0HtEdZQdSDYjDsoTyNGdMrMA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/rust/rust.min.js"
        integrity="sha512-g3Nhw36S0p4ZJQcky87D5M+vZbFvLrgsHWYltUy5IW0zKbvi8GlPRjJSo2CyUyQiU01Ier7u+rBABDs3BawKyQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/clike/clike.min.js"
        integrity="sha512-l8ZIWnQ3XHPRG3MQ8+hT1OffRSTrFwrph1j1oc1Fzc9UKVGef5XN9fdO0vm3nW0PRgQ9LJgck6ciG59m69rvfg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/ayu-dark.min.css"
        integrity="sha512-mV3RUXi1gt22jDb4UyRBFhZVFgAIiOfRE6ul+2l1Hcj6glyg6x4xlnjPH+neGm/t6XrFmsMRu4++McQu0asjqg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        .CodeMirror {
            border: 1px solid #eee;
            height: 100%;
        }
    </style>
</head>

<body style="height: 100%">
    <script type="module">
        import init, { compile_and_run } from './web.js';
        init();

        var source = CodeMirror.fromTextArea(document.getElementById("source"), {
            mode: "rust",
            lineNumbers: true,
            indentUnit: 4,
            theme: 'ayu-dark',
            autoRefresh: true,
        });
        source.setSize("100%", "40em");
        setInterval(function () {
            document.getElementById("source").value = source.getValue();
            source.refresh()
        }, 50);
        var output = CodeMirror.fromTextArea(document.getElementById("output"), {
            mode: "text/x-csrc",
            lineNumbers: true,
            indentUnit: 4,
            theme: 'ayu-dark',
            autoRefresh: true,
        });
        output.setSize("100%", "100%");
        setInterval(function () {
            if (output.getValue() != document.getElementById("output").value) {
                output.setValue(document.getElementById("output").value);
                output.refresh()
            }
        }, 50);
        function setExampleProgram() {
            console.log(document.getElementById("example").value);
            switch (document.getElementById("example").value) {
                case "aes":
                    source.setValue(`proc bitxor(a: Int, b: Int) -> Int = core {
    bitwise-xor [SP], [SP - 1] pop
} in

proc bitor(a: Int, b: Int) -> Int = core {
    bitwise-or [SP], [SP - 1] pop
} in

proc bitnand(a: Int, b: Int) -> Int = core {
    bitwise-nand [SP], [SP - 1] pop
} in

proc bitand(a: Int, b: Int) -> Int = core {
    bitwise-and [SP], [SP - 1] pop
} in

proc bitnot(x: Int) -> Int = core {
    bitwise-not [SP]
} in

proc puthex(n: Int, lower: Bool) = {
    if (n < 16) {
        put (n + if (n < 10) {
            48
        } else if lower {
            87
        } else {
            55
        }) as Char
    } else {
        puthex(n / 16, lower);
        puthex(n % 16, lower)
    }
} in

proc putbyte(n: Int, lower: Bool) = {
    puthex(n / 16, lower);
    puthex(n % 16, lower)
} in

const getchar = proc() -> Char = core {
    next SP
    get-char [SP]
} in

proc ln() = {
    put '\\n'
} in

proc lsh(a: Int, b: Int) -> Int = {
    while b {
        a = a * 2;
        b = b - 1;
    };
    a
} in

proc rsh(a: Int, b: Int) -> Int = {
    let added = -2147483648, i = 0, negative = a < 0 in {
        while (i < b - 1) {
            added /= 2;
            i += 1;
        };
        if negative { a = bitnot(a) };
        while b {
            a /= 2;
            b -= 1;
        };
        if negative { a = bitxor(bitnot(a), added) };
    };
    a
} in

proc xtime(n: Int) -> Int = {
    n = bitand(n, 255) * 2;
    if (n < 256) n
    else (bitxor(n, 27))
} in

proc mul(a: Int, b: Int) -> Int = {
    a = bitand(a, 255);
    b = bitand(b, 255);
    let result = 0,
        next_term = a,
        i = 0 in {
        while (i < 8) {
            if (bitand(rsh(b, i), 1)) {
                result = bitxor(result, next_term);
            };
            next_term = xtime(next_term);
            i += 1;
        };
        bitand(result, 255)
    }
} in

type State = [Int * 16] in

proc row_major(c0r0: Int, c1r0: Int, c2r0: Int, c3r0: Int,
    c0r1: Int, c1r1: Int, c2r1: Int, c3r1: Int,
    c0r2: Int, c1r2: Int, c2r2: Int, c3r2: Int,
    c0r3: Int, c1r3: Int, c2r3: Int, c3r3: Int
) -> State = {[
    c0r0,
    c0r1,
    c0r2,
    c0r3,

    c1r0,
    c1r1,
    c1r2,
    c1r3,

    c2r0,
    c2r1,
    c2r2,
    c2r3,

    c3r0,
    c3r1,
    c3r2,
    c3r3,
]} in

proc col_major(c0r0: Int, c0r1: Int, c0r2: Int, c0r3: Int,
    c1r0: Int, c1r1: Int, c1r2: Int, c1r3: Int,
    c2r0: Int, c2r1: Int, c2r2: Int, c2r3: Int,
    c3r0: Int, c3r1: Int, c3r2: Int, c3r3: Int,
) -> State = {[
    c0r0,
    c0r1,
    c0r2,
    c0r3,

    c1r0,
    c1r1,
    c1r2,
    c1r3,

    c2r0,
    c2r1,
    c2r2,
    c2r3,

    c3r0,
    c3r1,
    c3r2,
    c3r3,
]} in

proc get(self: &State, x: Int, y: Int) -> Int = {
    self[0][x + y * 4]
} in

proc set(self: &State, x: Int, y: Int, val: Int) = {
    self[0][x + y * 4] = val;
} in

proc putstate(self: State) = {
    let i = 0, j = 0 in {
        while i < 4 {
            while j < 4 {
                putbyte(get(&self, j, i), false);
                put ' ';
                j += 1;
            };
            ln();
            j = 0;
            i += 1;
        }
    }
} in

proc rot_row(self: State, y: Int, n: Int) -> State = {
    while n {
        let a = get(&self, 0, y),
            b = get(&self, 1, y),
            c = get(&self, 2, y),
            d = get(&self, 3, y) in {
            set(&self, 0, y, b);
            set(&self, 1, y, c);
            set(&self, 2, y, d);
            set(&self, 3, y, a);
        };
        n -= 1;
    };
    self
} in

proc shift_rows(self: State) -> State = {
    rot_row(rot_row(rot_row(self, 1, 1), 2, 2), 3, 3)
} in

proc inverse_shift_rows(self: State) -> State = {
    rot_row(rot_row(rot_row(self, 1, 3), 2, 2), 3, 1)
} in

proc add_round_key(self: State, round_key: State) -> State = {
    let i = 0,
        self_int_ptr = (&self) as &Int,
        round_key_int_ptr = (&round_key) as &Int in {
        while i < 16 {
            self_int_ptr[i] = bitxor(self_int_ptr[i], round_key_int_ptr[i]);
            i += 1;
        };
        self
    }
} in

proc mix_columns(self: State) -> State = {
    let j = 0 in while j < 4 {
        let s0 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 2), mul(get(&self, j, 1), 3)), get(&self, j, 2)), get(&self, j, 3)),
            s1 = bitxor(bitxor(bitxor(get(&self, j, 0), mul(get(&self, j, 1), 2)), mul(get(&self, j, 2), 3)), get(&self, j, 3)),
            s2 = bitxor(bitxor(bitxor(get(&self, j, 0), get(&self, j, 1)), mul(get(&self, j, 2), 2)), mul(get(&self, j, 3), 3)),
            s3 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 3), get(&self, j, 1)), get(&self, j, 2)), mul(get(&self, j, 3), 2)) in {
            
            set(&self, j, 0, s0);
            set(&self, j, 1, s1);
            set(&self, j, 2, s2);
            set(&self, j, 3, s3);
        };
        j += 1;
    };
    self
} in

proc inverse_mix_columns(self: State) -> State = {
    let j = 0 in while j < 4 {
        let s0 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 14), mul(get(&self, j, 1), 11)), mul(get(&self, j, 2), 13)), mul(get(&self, j, 3), 9)),
            s1 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 9),  mul(get(&self, j, 1), 14)), mul(get(&self, j, 2), 11)), mul(get(&self, j, 3), 13)),
            s2 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 13), mul(get(&self, j, 1), 9)),  mul(get(&self, j, 2), 14)), mul(get(&self, j, 3), 11)),
            s3 = bitxor(bitxor(bitxor(mul(get(&self, j, 0), 11), mul(get(&self, j, 1), 13)), mul(get(&self, j, 2), 9)),  mul(get(&self, j, 3), 14)) in {
            
            set(&self, j, 0, s0);
            set(&self, j, 1, s1);
            set(&self, j, 2, s2);
            set(&self, j, 3, s3);
        };
        j += 1;
    };
    self
} in

proc sub_byte(byte: Int) -> Int = {
    let S_BOX = [[99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118], [202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192], [183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21], [4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117], [9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132], [83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207], [208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168], [81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210], [205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115], [96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219], [224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121], [231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8], [186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138], [112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158], [225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223], [140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]] in {
        byte = bitand(byte, 255);
        let row = bitand(rsh(byte, 4), 15),
            col = bitand(byte, 15) in
            S_BOX[row][col]
    }
} in

proc inverse_sub_byte(byte: Int) -> Int = {
    let INVERSE_S_BOX = [[82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251], [124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203], [84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78], [8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37], [114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146], [108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132], [144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6], [208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107], [58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115], [150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110], [71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27], [252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244], [31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95], [96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239], [160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97], [23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]] in {
        byte = bitand(byte, 255);
        let row = bitand(rsh(byte, 4), 15),
            col = bitand(byte, 15) in
            INVERSE_S_BOX[row][col]
    }
} in


proc sub_bytes(self: State) -> State = {
    let i = 0, j = 0 in {
        while i < 4 {
            while j < 4 {
                set(&self, j, i, sub_byte(get(&self, j, i)));
                j += 1;
            };
            j = 0;
            i += 1;
        };
    };
    self
} in

proc inverse_sub_bytes(self: State) -> State = {
    let i = 0, j = 0 in {
        while i < 4 {
            while j < 4 {
                set(&self, j, i, inverse_sub_byte(get(&self, j, i)));
                j += 1;
            };
            j = 0;
            i += 1;
        };
    };
    self
} in

type AESKeyType = enum {AES256, AES192, AES128} in
type AESKeyData = union {
    AES256: [Int * 32],
    AES192: [Int * 24],
    AES128: [Int * 16]
} in
type Key = struct {
    ty: AESKeyType,
    key: AESKeyData
} in

proc get_key_len(key: Key) -> Int = {
    match (key.ty) {
        AES256 of AESKeyType => 8,
        AES192 of AESKeyType => 6,
        AES128 of AESKeyType => 4
    }
} in

proc get_key_rounds(key: Key) -> Int = {
    match (key.ty) {
        AES256 of AESKeyType => 14,
        AES192 of AESKeyType => 12,
        AES128 of AESKeyType => 10
    }
} in

proc get_key_size(key: Key) -> Int = {
    match (key.ty) {
        AES256 of AESKeyType => 32,
        AES192 of AESKeyType => 24,
        AES128 of AESKeyType => 16
    }
} in

proc get_key_data(key: &Key) -> &Int = {
    (&key->key) as &Int
} in

proc putkey(key: Key) -> None = {
    match (key.ty) {
        AES256 of AESKeyType => put "AES256",
        AES192 of AESKeyType => put "AES192",
        AES128 of AESKeyType => put "AES128"
    };
    put " ";
    let i = 0, size = get_key_size(key), data = get_key_data(&key) in 
        while i < size {
            putbyte(data[i], false);
            i += 1;
        }
} in

proc sub_word(word: Int) -> Int = {
    let byte0 = sub_byte(bitand(rsh(word, 24), 255)),
        byte1 = sub_byte(bitand(rsh(word, 16), 255)),
        byte2 = sub_byte(bitand(rsh(word, 8), 255)),
        byte3 = sub_byte(bitand(word, 255)) in
        (lsh(byte0, 24) + lsh(byte1, 16) + lsh(byte2, 8) + byte3)
} in

proc rot_word(word: Int) -> Int = {
    let byte0 = bitand(rsh(word, 24), 255),
        byte1 = bitand(rsh(word, 16), 255),
        byte2 = bitand(rsh(word, 8), 255),
        byte3 = bitand(word, 255) in
        (lsh(byte1, 24) + lsh(byte2, 16) + lsh(byte3, 8) + byte0)
} in

proc word(byte3: Int, byte2: Int, byte1: Int, byte0: Int) -> Int = {
    (lsh(byte3, 24) + lsh(byte2, 16) + lsh(byte1, 8) + byte0)
} in

proc bytes(word: Int) -> [Int * 4] = {
    let byte0 = bitand(rsh(word, 24), 255),
        byte1 = bitand(rsh(word, 16), 255),
        byte2 = bitand(rsh(word, 8), 255),
        byte3 = bitand(word, 255) in
        [byte0, byte1, byte2, byte3]
} in

proc round_key(word0: Int, word1: Int, word2: Int, word3: Int) -> State = {
    let bytes0 = bytes(word0),
        bytes1 = bytes(word1),
        bytes2 = bytes(word2),
        bytes3 = bytes(word3) in
            col_major(bytes0[0], bytes1[0], bytes2[0], bytes3[0],
            bytes0[1], bytes1[1], bytes2[1], bytes3[1],
            bytes0[2], bytes1[2], bytes2[2], bytes3[2],
            bytes0[3], bytes1[3], bytes2[3], bytes3[3])
} in

proc alloc(size: Int) -> &Int = std {
    alloc [SP]
} in

proc free(ptr: &Int) = std { free[SP] pop } in

proc key_expansion(key: Key, nr: Int, nk: Int) -> &Int = {
    let key_data = get_key_data(&key),
        w: &Int = alloc(4 * (nr + 1) * sizeof(Int)),
        i = 0 in {
        while i < nk {
            (w[i]) = word(
                key_data[4 * i],
                key_data[4 * i + 1],
                key_data[4 * i + 2],
                key_data[4 * i + 3],
            );
            i = i + 1;
        };

        i = nk;
        let rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54] in {
            while i < 4 * (nr + 1) {
                let tmp = w[i - 1] in {
                    if (i % nk == 0) {
                        tmp = bitxor(sub_word(rot_word(tmp)), word(rcon[i / nk - 1], 0, 0, 0));
                    } else {
                        if (nk == 8 and i % nk == 4) {
                            tmp = sub_word(tmp);
                        }
                    };
                    w[i] = bitxor(w[i - nk], tmp);
                };
                i = i + 1;
            }
        };
        w
    }
} in

proc aes_256_key(key: [Int * 32]) -> Key = {
    struct {
        ty = AES256 of AESKeyType,
        key = union {
            AES256 = key,
            AESKeyData..
        }
    }
} in

proc aes_192_key(key: [Int * 24]) -> Key = {
    struct {
        ty = AES192 of AESKeyType,
        key = union {
            AES192 = key,
            AESKeyData..
        }
    }
} in

proc aes_128_key(key: [Int * 16]) -> Key = {
    struct {
        ty = AES128 of AESKeyType,
        key = union {
            AES128 = key,
            AESKeyData..
        }
    }
} in

proc cipher(self: State, key: Key) -> State = {
    let result = self,
        i = 4,
        len = get_key_len(key),
        rounds = get_key_rounds(key),
        k = key_expansion(key, rounds, len)
        in {

        result = add_round_key(result, round_key(k[0], k[1], k[2], k[3]));
        while (i < 4 * (rounds + 1)) {
            let rk = round_key(k[i], k[i + 1], k[i + 2], k[i + 3]) in {
                result = shift_rows(sub_bytes(result));
                if (i / 4 != rounds) {
                    result = mix_columns(result);
                };
                result = add_round_key(result, rk);
            };
            i += 4;
        };
        free(k);
        result
    }
} in

proc inverse_cipher(self: State, key: Key) -> State = {
    let result = self,
        len = get_key_len(key),
        rounds = get_key_rounds(key),
        i = 4 * rounds,
        k = key_expansion(key, rounds, len)
        in {

        while i > 0 {
            let rk = round_key(k[i], k[i + 1], k[i + 2], k[i + 3]) in {
                result = add_round_key(result, rk);
                if (i / 4 != rounds) {
                    result = inverse_mix_columns(result);
                };
                result = inverse_sub_bytes(inverse_shift_rows(result));
            };
            i -= 4;
        };
        result = add_round_key(result, round_key(k[0], k[1], k[2], k[3]));
        free(k);
        result
    }
} in

proc between(lower: Int, n: Int, upper: Int) -> Bool = {
    if (n < lower) {
        return false
    };

    if (n > upper) {
        return false
    };

    true
} in

proc gethexdigit() -> Int = {
    let digit = getchar() as Int in
        if (between(48, digit, 57)) {
            digit - 48
        } else if (between(65, digit, 70)) {
            digit - 55
        } else if (between(97, digit, 102)) {
            digit - 87
        } else {
            0
        }
} in

proc getbyte() -> Int = {
    gethexdigit() * 16 + gethexdigit()
} in

let state = row_major(
    0, 1, 2, 3,
    4, 5, 6, 7,
    8, 9, 10, 11,
    12, 13, 14, 15
) in {
    let key = aes_128_key([
        0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 10, 11, 12, 13, 14, 15,
    ]) in {
        put "key: \\n";
        putkey(key);
        put "\\ninput:\\n";
        putstate(state);

        state = cipher(state, key);
        put "output:\\n";
        putstate(state);
        state = inverse_cipher(state, key);
        
        put "inverse:\\n";
        putstate(state);
    };
}`);
                    break;
                case "quicksort":
                    source.setValue(`proc bitxor(a: Int, b: Int) -> Int = core {
    bitwise-xor [SP], [SP - 1]
    pop
} in

proc bitor(a: Int, b: Int) -> Int = core {
    bitwise-or [SP], [SP - 1]
    pop
} in

proc bitnand(a: Int, b: Int) -> Int = core {
    bitwise-nand [SP], [SP - 1]
    pop
} in

proc bitand(a: Int, b: Int) -> Int = core {
    bitwise-and [SP], [SP - 1]
    pop
} in

proc bitnot(x: Int) -> Int = core {
    bitwise-not [SP]
} in

proc alloc(size: Int) -> &Cell = std {
    alloc [SP]
} in

proc free(ptr: &Int) = std {
    free [SP]
    pop
} in

proc puthex(n: Int, lower: Bool) -> None = {
    if (n < 16) {
        put (n + if (n < 10) {
            48
        } else if lower {
            87
        } else {
            55
        }) as Char
    } else {
        puthex(n / 16, lower);
        puthex(n % 16, lower)
    }
} in

proc putbyte(n: Int, lower: Bool) -> None = {
    puthex(n / 16, lower);
    puthex(n % 16, lower)
} in


proc ln() -> None = {
    put '\\n'
} in

proc min(x: Int, y: Int) -> Int = {
    if (x < y) x else y
} in
proc max(x: Int, y: Int) -> Int = {
    if (x > y) x else y
} in


type List = struct { data: Int, next: &List } in

proc sort(node: &List) -> None = {
    if (node->next != Null) {
        sort(node->next);
        let a = min(node->data, node->next->data),
            b = max(node->data, node->next->data)
            in {
            if (b != node->data) {
                sort(node->next);
            };
            node->data = a;
            node->next->data = b;
        };
    }
} in

proc len(node: &List) -> Int = {
    if (node != Null) {
        len(node->next) + 1
    } else {
        0
    }
} in


proc index(node: &List, n: Int) -> &List = {
    while n {
        node = node->next;
        n -= 1;
    };
    node
} in

proc swapi(a: &Int, b: &Int) = {
    let tmp = (*a) in {
        (*a) = *b;
        (*b) = tmp;
    }
} in

proc partition_arr(arr: &Int, low: Int, high: Int) -> Int = {
    let pivot = arr[high],
        i = low - 1,
        j = low in {
        while j < high {
            if (arr[j] <= pivot) {
                i += 1;
                swapi(&arr[j], &arr[i]);
            };
            j += 1
        };
        swapi(&arr[i + 1], &arr[high]);
        i + 1
    }
} in

proc quicksort_arr(arr: &Int, low: Int, high: Int) = {
    if (low < high) {
        let pi = partition_arr(arr, low, high) in {
            quicksort_arr(arr, low, pi - 1);
            quicksort_arr(arr, pi + 1, high);
        }
    }
} in

const SIZE = 100 in
let arr: &Int = alloc(SIZE * 2) as &Int, i = 0, a = 5, b = 6 in {
    put "unsorted: [";
    while i < SIZE {
        arr[i] = SIZE - i;
        put arr[i];
        if (i < SIZE - 1) {
            put ", ";
        };
        i += 1;
    };
    put "]\\n";
    quicksort_arr(arr, 0, SIZE - 1);
    put "sorted: [";
    i = 0;
    while i < SIZE {
        put arr[i];
        if (i < SIZE - 1) {
            put ", ";
        };
        i += 1;
    };
    put "]\\n";
}`);
                    break;
                case "lambda-sim":
                    source.setValue(`type Op = struct {
    apply: proc(struct {x: Int}, Int) -> Int,
    state: struct {x: Int}
} in

proc mul(n: Int) -> Op = {
    struct {
        apply = proc(state: struct{x: Int}, y: Int) -> Int = {
            state.x * y
        },
        state = struct {x=n}
    }
} in

proc add(n: Int) -> Op = {
    struct {
        apply = proc(state: struct{x: Int}, y: Int) -> Int = {
            state.x + y
        },
        state = struct {x=n}
    }
} in

proc app(op: Op, y: Int) -> Int = {
    op.apply(op.state, y)
} in

proc putdec(n: Int) = {
    if (n < 10) {
        put (n + 48) as Char
    } else {
        putdec(n / 10);
        put (n % 10 + 48) as Char
    }
} in

proc puthex(n: Int, lower: Bool) = {
    if (n < 16) {
        put (n + if (n < 10) {
            48
        } else if lower {
            87
        } else {
            55
        }) as Char
    } else {
        puthex(n / 16, lower);
        puthex(n % 16, lower)
    }
} in

proc putbyte(n: Int, lower: Bool) = {
    puthex(n / 16, lower);
    puthex(n % 16, lower)
} in

proc ln() = {
    put '\\n'
} in

let double = mul(2),
    triple = mul(3) in {
    putdec(
        app(add(10), app(triple, app(double, 5)))
    );
    ln();

    putbyte(255, false);
}`);
                    break;
<<<<<<< HEAD
                case "if-let":
                    source.setValue(`type Dir = enum { North, South, East, West } in

let expr = (South of Dir, 2, struct {x=5, y=-6}) in
    if let (South of Dir, b, c) = expr {
        put "Matched!\\n";
        put expr;
    } else {
        put "No match!"
    }`);
                    document.getElementById("input").value = "";
                    break;
                case "match":
                    source.setValue(`type Dir = enum { North, South, East, West } in

let expr = (South of Dir, 2, struct {x=5, y=-6}) in
    match expr {
        (North of Dir, _, _)
        | (East of Dir, _, _)
        | (West of Dir, _, _)
        | (South of Dir, 3, _) => put "Incorrect!\\n",
        (South of Dir, 2, struct {x=a, y=b}) => {
            if (a == 5 and b == -6) {
                put "Correct!\\n"
            } else {
                put "Incorrect!\\n"
            }
        },
        _ => put "Default! (incorrect)\\n"
    }`);
                    document.getElementById("input").value = "";
                    break;
                case "thermostat":
                    source.setValue(`type State = enum {
    Heating,
    Cooling,
    Idle
} in

type Kelvin = unit Kelvin = Float in
type Celcius = unit Celcius = Float in
type Fahrenheit = unit Fahrenheit = Float in

proc get_temperature() -> Kelvin = core {
    next SP
    get [SP], thermometer #0
} in

proc turn_on_heater() = core {
    set A, 1
    put A, heater #0
    put-str "[Heater on]\\n", stderr.char
} in

proc turn_off_heater() = core {
    set A, 0
    put A, heater #0
    put-str "[Heater off]\\n", stderr.char
} in

proc turn_on_cooler() = core {
    set A, 1
    put A, cooler #0
    put-str "[Cooler on]\\n", stderr.char
} in

proc turn_off_cooler() = core {
    set A, 0
    put A, cooler #0
    put-str "[Cooler off]\\n", stderr.char
} in

proc read_power_button() -> Bool = core {
    next SP
    get [SP], button #0
} in

proc read_up_button() -> Bool = core {
    next SP
    get [SP], button #1
} in

proc read_down_button() -> Bool = core {
    next SP
    get [SP], button #2
} in

proc putint(n: Int) = core {
    put-int [SP]
} in

proc putchar(c: Char) = core {
=======
                case "pattern-matching":
                    source.setValue(`type Dir = enum { North, South, East, West } in

proc alloc(n: Int) -> &Cell = std {
    alloc [SP]
} in

proc test(i: Int) -> Char = {
    match i {
        0 => 'a',
        1 => 'b',
        2 => 'c',
        3 => 'd',
        4 => 'e',
        5 => 'f',
        6 => 'g',
        7 => 'h',
        8 => 'i',
        9 => 'j',
        _ => '?'
    }
} in

proc write(user_ptr: &Char, len: Int) -> None = {
    match user_ptr {
        Null => put "Null pointer!\\n",
        valid_ptr => {
            let i = 0 in {
                while i < len {
                    put valid_ptr[i];
                    i += 1
                }
            }
        }
    }
} in


type List = (Int, &List) in

proc putlist(l: &List) -> None = {
    match l {
        Null => put '\\n',
        valid_ptr => {
            put valid_ptr->0;
            put ' ';
            putlist(valid_ptr->1)
        }
    }
} in

let i = 0,
    pos = struct { x = 16, y = -17 },
    dir = South of Dir,
    g = (North of Dir, 2, 3, pos),
    x = match (dir, (6, 'a', pos)) {
    (North of Dir, (6, 'b', _)) => put "Wow, north 1!\\n",
    (South of Dir, (5, 'a', _)) => put "Wow, north 2!\\n",
    (North of Dir, (6, 'a', _)) => put "Wow, north 3!\\n",
    (North of Dir, (5, 'b', _)) => put "Wow, north 4!\\n",
    (North of Dir, (5, 'a', _)) => put "Wow, north 5!\\n",
    (South of Dir, (6, 'a', struct { x = 16, y = -16})) => put "Wow, north 6!\\n",
    (South of Dir, (6, 'a', struct { x = 16, y = h})) => {
        put h;
        put "Wow, north 7!\\n";
    },
    _ => put "default!\\n"
} in {
    while i < 10 {
        put test(i);
        i += 1
    };
    put "\\nDone!\\n";
    
    let str = "Hello, world!" in {
        write((&str) as &Char, 13)
    };

    if let (North of Dir, b, c, struct {x=d, y=e}) = g {
        put b;
        put c;
        put d;
        put e;
    } else {
        put "Nope!"
    };

    match (5, 8) {
        (4, x) | (x, 5) => put 'g',
        _ => put "Nope!"
    };


    type Tag = enum { A, B, C },
        Union = union {
        a: Int,
        b: Float,
        c: Bool
    } in match (C of Tag, union {a = 5, Union..}) {
        (A of Tag, u) => { put "\\na\\n"; put u },
        (B of Tag, u) => { put "\\na\\n"; put u },
        (C of Tag, u) => { put "\\na\\n"; put u },
        _ => put "Nope!"
    };
    put '\\n';


    let n = 16 in
        match (alloc(n)) {
            Null => put "Null pointer!\\n",
            valid_ptr => {
                put "Allocated ";
                put n;
                put " cells at ";
                put valid_ptr;
                put '\\n'
            }
        };


    write(Null, 10);
    
    let x = (1, Null),
        y = (2, &x),
        z = (3, &y),
        w = (4, &z) in {
        putlist(&w)
    };
}`);
                    document.getElementById("input").value = "";
                    break;
                case "cat":
                    source.setValue(`const putchar = proc(ch: Char) -> None = core {
>>>>>>> 5cb8140 (Merged main docs)
    put-char [SP]
} in

proc putfloat(c: Float) = core {
    put-float [SP]
} in

proc f_to_c(f: Fahrenheit) -> Celcius = {
    ((f as Float - 32.0) * 5.0 / 9.0) as Celcius
} in

proc c_to_f(c: Celcius) -> Fahrenheit = {
    ((c as Float * 9.0 / 5.0) + 32.0) as Fahrenheit
} in

proc k_to_c(k: Kelvin) -> Celcius = {
    (k as Float - 273.15) as Celcius
} in 

proc c_to_k(c: Celcius) -> Kelvin = {
    (c as Float + 273.15) as Kelvin
} in

proc f_to_k(f: Fahrenheit) -> Kelvin = {
    c_to_k(f_to_c(f))
} in

proc k_to_f(k: Kelvin) -> Fahrenheit = {
    c_to_f(k_to_c(k))
} in

proc putf(temp: Fahrenheit) = {
    putfloat(temp as Float);
    putchar('°');
    putchar('F')
} in

proc putc(temp: Celcius) = {
    putfloat(temp as Float);
    putchar('°');
    putchar('C')
} in

proc putk(temp: Kelvin) = {
    putfloat(temp as Float);
    putchar('°');
    putchar('K')
} in


proc main() = {
    let state = Idle of State,
        desired_temp = 20.0 as Celcius,
        current_temp = k_to_c(get_temperature()),
        up_button = read_up_button(),
        down_button = read_down_button(),
        power_button = read_power_button(),
        i = 0
    in while (not power_button and i < 100) {
        if (up_button) {
            desired_temp = desired_temp + 0.1 as Celcius
        };

        if (down_button) {
            desired_temp = desired_temp - 0.1 as Celcius
        };

        put "Current temp: ";
        put current_temp;
        put "\\nDesired temp: ";
        put desired_temp;
        put "\\nCurrent state: ";
        put state;
        put "\\n";
        
        if (current_temp > desired_temp) {
            put "Too hot\\n"
        } else if (current_temp < desired_temp) {
            put "Too cold\\n"
        } else {
            put "Just right\\n"
        };

        match (state) {
            Heating of State => {
                put "Heating\\n";
                if (current_temp > desired_temp) {
                    turn_off_heater();
                    state = Idle of State
                }
            },
            Cooling of State => {
                put "Cooling\\n";
                if (current_temp < desired_temp) {
                    turn_off_cooler();
                    state = Idle of State
                }
            },
            Idle of State => {
                put "Idle\\n";
                if (current_temp > desired_temp) {
                    turn_on_cooler();
                    state = Cooling of State
                } else if (current_temp < desired_temp) {
                    turn_on_heater();
                    state = Heating of State
                }
            }
        };

        up_button = read_up_button();
        down_button = read_down_button();
        power_button = read_power_button();
        current_temp = k_to_c(get_temperature());
        i += 1
    };
    put "Goodbye!\\n"
} in main()`);
                    document.getElementById("input").value = "";
                    break;
                case "cat":
                    source.setValue(`proc getchar() -> Char = core {
    next SP
    get-char [SP]
} in

let ch = getchar() in while ch {
    put ch;
    ch = getchar();
}`);
                    document.getElementById("input").value = "this is a cat program!";
                    break;
                case "factorial":
                    source.setValue(`proc getint() -> Int = core {
    next SP
	get-int [SP]
} in

proc fact(n: Int) -> Int = {
    if n
        (n * fact(n - 1))
        else 1
} in

put fact(getint())`);
                    document.getElementById("input").value = "5";
                    break;
                case "units":
                    source.setValue(`type
    Kilometer = unit Kilometer = Int,
    Meter = unit Meter = Int,
    Second = unit Second = Int,
    MetersPerSecond = unit MetersPerSec = Meter,
    MetersPerSecondPerSecond = unit MetersPerSecondPerSecond = MetersPerSecond
in

proc shift_pos_by_dist(x0: Meter, dx: Meter) -> Meter = {
    (x0 as Int + dx as Int) as Meter
} in

proc shift_pos_with_vel(x0: Meter, v: MetersPerSecond, t: Second) -> Meter = {
    (x0 as Int + (v as Int * t as Int)) as Meter
} in

proc shift_pos_with_accel(x0: Meter, a: MetersPerSecondPerSecond, t: Second) -> Meter = {
    (x0 as Int + a as Int * t as Int * t as Int / 2) as Meter
} in

proc km_to_m(km: Kilometer) -> Meter = {
    (km as Int * 1000) as Meter
} in

proc shift_pos_with_vel_and_accel(x0: Meter, v0: MetersPerSecond, a: MetersPerSecondPerSecond, t: Second) -> Meter = {
    shift_pos_with_vel(shift_pos_with_accel(x0, a, t), v0, t)
} in

let x0: Meter = km_to_m(1 as Kilometer),
    v0: MetersPerSecond = 5 as MetersPerSecond,
    accel: MetersPerSecondPerSecond = 2 as MetersPerSecondPerSecond,
    t: Second = 10 as Second,
    in put shift_pos_with_vel_and_accel(x0, v0, accel, t)`);
                    break;
                case "collatz":
                    source.setValue(`proc getint() -> Int = core {
    next SP
    get-int [SP]
} in

proc step(n: Int) -> Int = {if (n % 2) (3 * n + 1) else n / 2} in
proc collatz(n: Int) -> Int = {
    let i = 0 in
        while n - 1 {
            i = i + 1;
            put i;
            put ": ";
            put n;
            put '\\n';
            n = step(n);
        };
    return n
} in collatz(getint())`);
                    document.getElementById("input").value = "129";
                    break;
                case "inline-asm":
                    source.setValue(`proc asm_init() = core {
    fun FACT
        set A, 0
        gt [SP], A, B
        if B
            push [SP]
            dec [SP]
            call FACT
            mul [SP], [SP - 1]
            pop
        else
            set [SP], 1
        end
    end
} in

proc fact(n: Int) -> Int = core {
    call FACT
} in {
    asm_init();

    put fact(5); put '\\n';
    put fact(10); put '\\n';
}`);
                    break;
                case "type-demo-1":
                    source.setValue(`const getchar = proc() -> Char = core {
    next SP
    get-char [SP]
} in

const alloc = proc(n: Int) -> &Int = std {
    alloc [SP]
} in

type List = let B = let T = Int in (T, &B) in B in

proc hmm() -> List = {
    ('~' as Int, Null)
} in

proc hmm2() -> List = {
    let ptr = alloc(sizeof(List)) as &List in {
        (*ptr) = hmm();
        (':' as Int, ptr)
    }
} in

proc hmm3() -> List = {
    let ptr = alloc(sizeof(List)) as &List in {
        (*ptr) = hmm2();
        ('!' as Int, ptr)
    }
} in

let x: let A = (Int, &A) in A
    = hmm3()
    in {
    put x.1->0 as Char;
    put ')'
}`);
                    break;
                case "type-demo-2":
                    source.setValue(`type A = Int,
    B = (Int, Int),
    C = ((Int, Int), Int),
    Test = proc(A, proc(A) -> B, proc(B) -> C) -> C
    in const
        a = 5,
        b = proc(x: Int) -> (Int, Int) = { (x, 6) },
        c = proc(x: (Int, Int)) -> ((Int, Int), Int) = { (x, 7) },
        test = proc(a: A, b: proc(A) -> B, c: proc(B) -> C) -> C = {
            c(b(a))
        }, hmm = proc(f: Test, x: Int) -> ((Int, Int), Int) = {
            f(x, b, c)
        } in {
            let result = hmm(test, a) in {
                put result.0.0;
                put result.0.1;
                put result.1;
            }
        }`);
                    break;
                case "hello world":
                    source.setValue(`{\n    put "Hello world!\\n";\n    put 1 + 2\n}\n`);
                    break;
                default:
                    console.log("Unknown example: " + example);
                    break;
            }
        }
        setExampleProgram();
        document.getElementById("example").addEventListener("change", () => {
            setExampleProgram();
<<<<<<< HEAD
            document.getElementById("example").addEventListener("change", () => {
                setExampleProgram();
                document.getElementById("source").value = source.getValue();
                source.refresh();
                compile_and_run();
            });
            document.getElementById("target").addEventListener("change", () => {
                document.getElementById("source").value = source.getValue();
                source.refresh();
                compile_and_run();
            });
            document.getElementById("run").addEventListener("click", compile_and_run, false);
        </script>
        <select id="example" style="height: 3em; float: left;">
            <option value="aes">AES</option>
            <option value="if-let">Pattern Match If-Let</option>
            <option value="match">Pattern Match Case</option>
            <option value="thermostat">Thermostat</option>
            <option value="quicksort">Quicksort</option>
            <option value="cat">Cat</option>
            <option value="units">Units</option>
            <option value="lambda-sim">Simulate Lambda Functions</option>
            <option value="factorial">Factorial</option>
            <option value="collatz">Collatz</option>
            <option value="inline-asm">Inline Assembly Demo</option>
            <option value="type-demo-1">Type System Demo 1</option>
            <option value="type-demo-2">Type System Demo 2</option>
=======
            document.getElementById("source").value = source.getValue();
            source.refresh();
            compile_and_run();
        });
        document.getElementById("target").addEventListener("change", () => {
            document.getElementById("source").value = source.getValue();
            source.refresh();
            compile_and_run();
        });
        document.getElementById("run").addEventListener("click", compile_and_run, false);
    </script>
    <select id="example" style="height: 3em; float: left;">
        <option value="aes">AES</option>
        <option value="quicksort">Quicksort</option>
        <option value="pattern-matching">Pattern Matching</option>
        <option value="units">Units</option>
        <option value="lambda-sim">Simulate Lambda Functions</option>
        <option value="inline-asm">Inline Assembly Demo</option>
        <option value="type-demo-1">Type System Demo 1</option>
        <option value="type-demo-2">Type System Demo 2</option>
        <option value="hello world">Hello world!</option>
        <option value="cat">Cat</option>
        <option value="factorial">Factorial</option>
        <option value="collatz">Collatz</option>
    </select>
    <div class="row">
        <div class="col"><textarea id="source"></textarea></div>
        <div class="col" style="height: 20em;">
            <textarea style="overflow: auto; background-color: black; color: white;" id="output"></textarea>
        </div>
    </div>
    <div>
        <textarea id="input" style="resize: none; float: left;" cols="10">Input Text</textarea>
        <select id="target" style="height: 3em; float: left;">
            <option value="run"><b>Click to see stages of output</b></option>
            <option value="run">Execution Output</option>
            <option value="asm">Assembly</option>
            <option value="vm">Virtual Machine Code</option>
            <option value="c">C Source</option>
>>>>>>> da6f5d3 (Added links to table in docs)
        </select>
        <button id="run" style="height: 3em; float: left;">Compile</button>
    </div>
</body>

</html>