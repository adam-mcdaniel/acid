mod math {
    const PI = 3.14159265358979323846;
    const TAU = 6.28318530717958647693;
    const EPSILON = 0.000001;
    const MAX_TRIG_ITERATIONS = 100;
    const MAX_SQRT_ITERATIONS = 20;
    const MAX_LOG_ITERATIONS = 200;

    fun factorial(n: Int): Int {
        if n <= 0 {
            return 1;
        }
        return n * factorial(n - 1);
    }

    impl Float {
        fun abs(self): Float {
            if self < 0 {
                return -self;
            }
            return self;
        }

        fun round(self): Int {
            if self < 0 {
                return (self - 0.5) as Int;
            }
            return (self + 0.5) as Int;
        }

        fun round_to(self, n: Int): Float {
            let mut factor = 1;
            for let mut i=0; i<n; i+=1; {
                factor *= 10;
            }
            return (self * factor).round() as Float / factor as Float;
        }
    }

    impl Int {
        fun abs(self): Int {
            if self < 0 {
                return -self;
            }
            return self;
        }
    }

    // Calculate the greatest common divisor of two numbers using Euclid's algorithm
    fun gcd(a: Int, b: Int): Int {
        if b == 0 {
            return a;
        }
        return gcd(b, a % b);
    }

    // Taylor series approximation of sine
    fun sin(mut x: Float): Float {
        x %= PI * 2;
        let mut result = 0.0;
        let mut term = x;
        let mut i = 1;
        while i < MAX_TRIG_ITERATIONS {
            result += term;
            term *= -x * x / (2 * i + 1) / (2 * i);
            i += 1;
        }
        return result;
    }

    // Taylor series approximation of cosine
    fun cos(x: Float): Float {
        return sin(x + PI / 2);
    }

    // Taylor series approximation of tangent
    fun tan(x: Float): Float {
        return sin(x) / cos(x);
    }

    fun asin(x: Float): Float {
        // Taylor series approximation of arcsine
        fun asin_approx(x: Float): Float {

            let x2 = x * x; // x^2
            let x4 = x2 * x2; // x^4
            let x6 = x4 * x2; // x^6
            let x8 = x6 * x2; // x^8
            let x10 = x8 * x2; // x^10
            let x12 = x10 * x2; // x^12

            return x * (1.0
                + (1.0 / 6.0) * x2
                + (3.0 / 40.0) * x4
                + (5.0 / 112.0) * x6
                + (35.0 / 1152.0) * x8
                + (63.0 / 2816.0) * x10
                + (231.0 / 13312.0) * x12);
        }

        // As x approaches 1, the series converges more slowly
        // add a condition to speed up the calculation
        if x.abs() > 0.9 {
            let complement = sqrt(1.0 - x * x);
            let result = PI / 2 - asin_approx(complement);
            if x < 0 {
                return -result;
            }
            return result;
        }

        return asin_approx(x);
    }

    // Taylor series approximation of arccosine
    fun acos(x: Float): Float {
        return PI / 2 - asin(x);
    }

    // Calculate the arctangent of a number
    fun atan(x: Float): Float {
        let x2 = x * x; // x^2
        let x3 = x2 * x; // x^3
        let x5 = x3 * x2; // x^5
        let x7 = x5 * x2; // x^7
        let x9 = x7 * x2; // x^9
        let x11 = x9 * x2; // x^11
        let x13 = x11 * x2; // x^13

        return x * (1.0
            - (1.0 / 3.0) * x2
            + (1.0 / 5.0) * x3
            - (1.0 / 7.0) * x5
            + (1.0 / 9.0) * x7
            - (1.0 / 11.0) * x9
            + (1.0 / 13.0) * x11
            - (1.0 / 15.0) * x13);
    }

    // Calculate the arctangent of a fraction
    fun atan2(y: Float, x: Float): Float {
        if x.abs() < EPSILON {
            if y > 0 {
                return PI / 2;
            } else if y < 0 {
                return -PI / 2;
            } else {
                return 0.0;
            }
        }
        if x > 0 {
            return atan(y / x);
        }
        if y > 0 {
            return atan(y / x) + PI;
        }
        return atan(y / x) - PI;
    }

    // Calculate the square root of a number using Newton's method
    fun sqrt(x: Float): Float {
        let mut result = x;
        let mut i = 0;
        while i < MAX_SQRT_ITERATIONS && result > EPSILON {
            result = (result + x / result) / 2;
            i += 1;
        }
        return result;
    }

    // Calculate the natural logarithm of a number
    fun ln(x: Float): Float {
        let mut result = 0.0;
        let mut term = (x - 1) / (x + 1);
        let mut i = 1;
        while i < MAX_LOG_ITERATIONS {
            result += term / i;
            term *= (x - 1) * (x - 1) / (x + 1) / (x + 1);
            i += 2;
        }
        return 2 * result;
    }

    // Calculate the base 10 logarithm of a number
    fun log10(x: Float): Float {
        return ln(x) / ln(10.0);
    }

    // Calculate the exponential of a number
    fun exp(x: Float): Float {
        let mut result = 1.0;
        let mut term = 1.0;
        let mut i = 1;
        while i < MAX_TRIG_ITERATIONS {
            term *= x / i;
            result += term;
            i += 1;
        }
        return result;
    }

    // Calculate the power of a number
    fun pow(x: Float, y: Float): Float {
        return exp(y * ln(x));
    }

    // Calculate the hyperbolic sine of a number
    fun sinh(x: Float): Float {
        return (exp(x) - exp(-x)) / 2;
    }

    // Calculate the hyperbolic cosine of a number
    fun cosh(x: Float): Float {
        return (exp(x) + exp(-x)) / 2;
    }

    // Calculate the hyperbolic tangent of a number
    fun tanh(x: Float): Float {
        return sinh(x) / cosh(x);
    }

    // Calculate the hyperbolic arcsine of a number
    fun asinh(x: Float): Float {
        return ln(x + sqrt(x * x + 1));
    }

    // Calculate the hyperbolic arccosine of a number
    fun acosh(x: Float): Float {
        return ln(x + sqrt(x * x - 1));
    }

    // Calculate the hyperbolic arctangent of a number
    fun atanh(x: Float): Float {
        return ln((1 + x) / (1 - x)) / 2;
    }

    // Calculate the hyperbolic arctangent of a fraction
    fun atanh2(y: Float, x: Float): Float {
        return atanh(y / x);
    }
}

mod mem {
    // A function for allocating memory
    fun malloc<T>(n: Int): &mut T {
        return alloc(n * sizeof<T>());
    }
}

mod env {
    // A function for halting the program
    fun exit(n: Int): ! {
        // `!` is the type of a value that never returns
        println("Exit: ", n);
        debug();
        while True {}
    }
}

mod io {
    // Import from math just to test
    from math import gcd;

    // Print a character to the screen
    fun putln<T>(x: T) {
        print(x);
        print('\n');
    }

    // Get a character from input
    fun getchar(): Char {
        let mut ch = ' ';
        input(&mut ch);
        return ch;
    }

    // Add these put/get functions as methods to the Char type
    impl Char {
        fun put(&self) { putln<Char>(*self); }

        fun get(): Char { return getchar(); }
    }
}

mod fallible {
    fun panic(msg: &Char): ! {
        print("Error: ", msg);
    }

    enum Result<T, E> {
        Ok(T),
        Err(E)
    }

    impl Result<T, E> {
        fun ok(x: T): Result<T, E> {
            return Result<T, E> of Ok(x);
        }

        fun err(x: E): Result<T, E> {
            return Result<T, E> of Err(x);
        }

        fun is_ok(&self): Bool {
            match self {
                &of Ok(_) => True,
                        _ => False
            }
        }

        fun is_err(&self): Bool {
            !self.is_ok()
        }

        fun unwrap(self): T {
            match self {
                of Ok(x) => x,
                _ => panic(&"Oh no, tried to unwrap an error!")
            }
        }
    }

    enum Option<T> {
        Some(T),
        Nothing
    }

    // Add some associated functions to the Option enum
    impl Option<T> {
        fun nullify(&mut self) {
            *self = Option<T> of Nothing;
        }

        fun as_ref(&self): Option<&T> {
            let inner = self as &T;
            if let &of Nothing = self {
                return Option<&T> of Nothing;
            }
            return Option<&T> of Some(inner);
        }

        fun as_ref_mut(&mut self): Option<&mut T> {
            let inner = self as &mut T;
            if let &of Nothing = self {
                return Option<&mut T> of Nothing;
            }
            return Option<&mut T> of Some(inner);
        }

        fun print(&self) {
            match self {
                &of Some(x) => print("Some(", x, ")"),
                _ => print("Nothing")
            }
        }

        fun println(&self) {
            self.print();
            print("\n");
        }

        fun map<U>(&self, f: fun(T) -> U): Option<U> {
            match *self {
                of Some(x) => Option<U> of Some(f(x)),
                _ => Option<U> of Nothing
            }
        }

        fun is_some(&self): Bool {
            match self {
                &of Some(_) => True,
                _ => False
            }
        }

        fun is_none(&self): Bool {
            match self {
                &of Some(_) => False,
                _ => True
            }
        }

        fun unwrap(self): T {
            match self {
                of Some(x) => x,
                _ => panic(&"called `Option.unwrap()` on a `Nothing` value")
            }
        }

        fun unwrap_or(self, default: T): T {
            match self {
                of Some(x) => x,
                _ => default
            }
        }
    }

}

mod int {
    const MAX_INT = 2147483647;
    const MIN_INT = -2147483648;
}

mod collections {
    from fallible import panic, Option;
    from mem import malloc;

    enum List<T> {
        Cons(T, &List<T>),
        Nil
    }
    
    impl List<T> {
        fun new(x: T): List<T> {
            List<T> of Cons(x, new List<T> of Nil);
        }
        
        fun cons(self, value: T): List<T> {
            return List<T> of Cons(value, new self);
        }
        
        fun head(&self): T {
            match self {
                &of Cons(x, _) => x,
                _ => panic(&"Got head of empty list!")
            }
        }
        
        fun print(&self) {
            match self {
                &of Cons(head, tail) => {
                    print(head);
                    print(" ");
                    tail.print();
                },
                _ => {}
            }
        }
        
        fun println(&self) {
            self.print();
            println();
        }

        fun map<U>(self, f: fun(T) -> U): List<U> {
            match self {
                of Cons(head, tail) => tail.map<U>(f).cons(f(head)),
                _ => List<U> of Nil
            }
        }
    }


    struct Vec<T> {
        data: &mut T,
        length: Int,
        cap: Int
    }

    fun memcpy<T>(dest: &mut T, src: &T, size: Int) {
        for let mut i=0; i<size; i+=1; {
            dest[i] = src[i];
        }
    }

    impl Vec<T> {
        fun make(): Vec<T> {
            let cap = 128;
            let mut data = alloc(cap * sizeof<T>()) as &mut T;
            return {
                data=data,
                length=0,
                cap=cap
            };
        }

        fun reserve(&mut self, cap: Int) {
            if cap > self.cap {
                let mut new_data = malloc<T>(cap);
                memcpy<T>(new_data, self.data, self.length);
                free(self.data);
                self.data = new_data;
                self.cap = cap;
            }
        }

        fun push(&mut self, x: T) {
            if self.length == self.cap {
                self.reserve(self.cap * 2);
            }
            self.data[self.length] = x;
            self.length += 1;
        }

        fun pop(&mut self): Option<T> {
            if self.length == 0 {
                return Option<T> of Nothing;
            }
            self.length -= 1;
            return Option<T> of Some(self.data[self.length]);
        }

        fun clear(&mut self) {
            self.length = 0;
        }

        fun print(&self) {
            print("[");
            for let mut i=0; i < self.length; i += 1; {
                print(self.data[i]);
                if i < self.length - 1 {
                    print(", ");
                }
            }
            print("]");
        }

        fun println(&self) {
            self.print();
            print("\n");
        }

        fun get(&self, i: Int): &T {
            return &(self.data[i]);
        }

        fun get_mut(&mut self, i: Int): &mut T {
            return &mut (self.data[i]);
        }

        fun set(&mut self, i: Int, x: T) {
            self.data[i] = x;
        }

        fun nth(&self, i: Int): Option<&T> {
            if i < 0 || i >= self.length {
                return Option<&T> of Nothing;
            }
            return Option<&T> of Some(self.get(i));
        }

        fun len(&self): Int {
            return self.length;
        }

        fun map<U>(&self, f: fun(T) -> U): Vec<U> {
            let mut new_vec = Vec.make<U>();
            for let mut i=0; i < self.length; i += 1; {
                new_vec.push(f(self.data[i]));
            }
            return new_vec;
        }

        fun reduce<U>(&self, f: fun(U, T) -> U, init: U): U {
            let mut result = init;
            for let mut i=0; i<self.length; i+=1; {
                result = f(result, self.data[i]);
            }
            return result;
        }

        fun drop(&mut self) {
            free(self.data);
        }
    }

    // Hash a value
    fun hash<T>(t: T): Int {
        let size = sizeof(t);
        let ptr = (&t) as &Int;
        
        let mut hashValue = 5381;
        fun left_shift(mut a: Int, mut b: Int): Int {
            while b {
                a *= 2;
                b -= 1;
            }
            return a;
        }

        for let mut i = 0; i < size; i += 1; {
            let mut value = ptr[i];
            while (value != 0) {
                let digit = value % 10;
                hashValue = (left_shift(hashValue, 5) + hashValue) + digit;
                value /= 10;
            }
        }

        if hashValue < 0 {
            hashValue = -hashValue;
        }
        
        return hashValue;
    }
    // Compare two values for equality
    fun eq<K>(a: K, b: K): Bool {
        let size = sizeof(a);
        let a_ptr = (&a) as &Int;
        let b_ptr = (&b) as &Int;
        
        for let mut i=0; i<size; i+=1; {
            if a_ptr[i] != b_ptr[i] {
                return False;
            }
        }
        return True;
    }

    struct Entry<K, V> {
        key: K,
        value: V
    }

    struct HashMap<K, V> {
        data: Vec<Option<Entry<K, V>>>,
        occupied: Int,
    }

    impl HashMap<K, V> {
        fun make(): HashMap<K, V> {
            let mut data = Vec.make<Option<Entry<K, V>>>();
            for let mut i=0; i < 128; i += 1; {
                data.push(Option<Entry<K, V>> of Nothing);
            }
            return {
                data=data,
                occupied=0
            };
        }

        fun len(&self): Int {
            return self.occupied;
        }

        fun contains_key(&self, key: K): Bool {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    return True;
                }
                index = (index + 1) % self.data.len();
            }
            return False;
        }
        
        fun insert(&mut self, key: K, value: V) {
            if self.occupied * 2 > self.data.len() {
                for let mut i=0; i < self.occupied * 2; i += 1; {
                    self.data.push(Option<Entry<K, V>> of Nothing);
                }
            }
            let mut index = (hash<K>(key)) % (self.data.len());
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    self.data.set(index, Option<Entry<K, V>> of Some({key=key, value=value}));
                    return ();
                }
                index = (index + 1) % self.data.len();
            }
            self.data.set(index, Option<Entry<K, V>> of Some({key=key, value=value}));
            self.occupied += 1;
        }

        fun remove(&mut self, key: K) {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    self.data.set(index, Option<Entry<K, V>> of Nothing);
                    self.occupied -= 1;
                    return ();
                }
                index = (index + 1) % self.data.len();
            }
        }
        
        fun get_and_unwrap(&self, key: K): V {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    match self.data.get(index).as_ref() {
                        of Some(inner) => {
                            return inner.value;
                        },
                        _ => ()
                    }
                }
                index = (index + 1) % self.data.len();
            }
            panic(&"called `HashMap.get_and_unwrap()` on a `Nothing` value");
        }

        fun get(&self, key: K): Option<&V> {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    match self.data.get(index).as_ref() {
                        of Some(inner) => {
                            return Option<&V> of Some(&(inner.value));
                        },
                        _ => ()
                    }
                }
                index = (index + 1) % self.data.len();
            }
            return Option<&V> of Nothing;
        }

        fun get_mut(&mut self, key: K): Option<&mut V> {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    match self.data.get_mut(index).as_ref_mut() {
                        of Some(inner) => {
                            return Option<&mut V> of Some(&mut (inner.value));
                        },
                        _ => ()
                    }
                }
                index = (index + 1) % self.data.len();
            }
            return Option<&mut V> of Nothing;
        }

        fun print(&self) {
            print("{");
            let mut first = True;
            for let mut i=0; i < self.data.len(); i += 1; {
                if self.data.get(i).is_some() {
                    if !first {
                        print(", ");
                    }
                    print(self.data.get(i).unwrap().key);
                    print(": ");
                    print(self.data.get(i).unwrap().value);
                    first = False;
                }
            }
            print("}");
        }

        fun println(&self) {
            self.print();
            print("\n");
        }

        fun drop(&mut self) {
            self.data.drop();
        }
    }
}

mod time {
    from fallible import Option;

    const SECONDS_PER_YEAR = 31556926;
    const SECONDS_PER_DAY = 86400;
    const SECONDS_PER_HOUR = 3600;
    

    struct Duration {
        us: Int,
        start: Option<Instant>,
        end: Option<Instant>
    }

    impl Duration {
        fun from_us(micros: Int): Duration {
            return { us=micros, start=Option<Instant> of Nothing, end=Option<Instant> of Nothing };
        }

        fun from_ms(millis: Int): Duration {
            return Duration.from_us(millis * 1000);
        }

        fun from_secs(seconds: Int): Duration {
            return Duration.from_us(seconds * 1000000);
        }

        fun from_mins(minutes: Int): Duration {
            return Duration.from_secs(minutes * 60);
        }

        fun from_hours(hours: Int): Duration {
            return Duration.from_mins(hours * 60);
        }

        fun as_secs(self): Int {
            return self.us / 1000000;
        }

        fun as_years(self): Float {
            return self.us as Float / 1000000.0 / SECONDS_PER_YEAR as Float;
        }
    }

    struct Instant {
        us: Int
    }

    // Get the time since the Unix epoch in microseconds
    extern fun microseconds_since_epoch(): Int;

    impl Instant {
        // Get the current time
        fun now(): Instant {
            return { us=microseconds_since_epoch() };
        }

        fun epoch(): Instant {
            return { us=0 };
        }

        fun as_secs(self): Int {
            return self.us / 1000000;
        }

        fun from_us_since_epoch(micros: Int): Instant {
            return { us=micros };
        }

        fun time_since_epoch(self): Duration {
            return Duration.from_us(self.us);
        }

        fun elapsed(self): Duration {
            let now = Instant.now();
            return {
                us=now.us - self.us,
                start=Option<Instant> of Some(self),
                end=Option<Instant> of Some(now)
            };
        }

        fun add(mut self, duration: Duration): Instant {
            self.us += duration.us;
            return self;
        }

        fun from_date(self: Date): Instant {
            let mut days = 0;
            for let mut y=1970; y<self.year; y+=1; {
                days += 365;
                if Date.date(y, 1, 1).is_leap_year() {
                    days += 1;
                }
            }
            let mut days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            if self.is_leap_year() {
                days_in_month[1] = 29;
            }
            for let mut m=1; m<self.month; m+=1; {
                days += days_in_month[m - 1];
            }
            days += self.day - 1;
            
            return Instant.from_us_since_epoch(days * SECONDS_PER_DAY * 1000000)
                .add(Duration.from_hours(self.hour))
                .add(Duration.from_mins(self.minute))
                .add(Duration.from_secs(self.second));
        }
    }

    struct Date {
        year: Int,
        month: Int,
        day: Int,
        hour: Int,
        minute: Int,
        second: Int
    }

    impl Date {
        fun date(year: Int, month: Int, day: Int): Date {
            return { year=year, month=month, day=day, hour=0, minute=0, second=0 };
        }

        fun is_leap_year(self): Bool {
            return self.year % 4 == 0 && (self.year % 100 != 0 || self.year % 400 == 0);
        }

        fun print(&self) {
            print(self.year, "-", self.month, "-", self.day);
        }
    }
}

mod physics {
    // Import from math just to test
    from time import Instant, Duration, SECONDS_PER_YEAR;

    // Calculate the distance between two points
    fun distance(x1: Float, y1: Float, x2: Float, y2: Float): Float {
        return math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    struct Point3D {
        x: Float,
        y: Float,
        z: Float
    }

    impl Point3D {
        fun new(x: Float, y: Float, z: Float): Point3D {
            return { x=x, y=y, z=z };
        }

        fun convert(self, f: fun(Float) -> Float): Point3D {
            return Point3D.new(f(self.x), f(self.y), f(self.z));
        }
    }


    const G_CONSTANT = 0.000000000066743;
    mod kinematics {
        // Calculate the gravitational force between two objects
        fun gravitational_force(m1: Float, m2: Float, r: Float): Float {
            return gravitational_acceleration(m1, r) * m2;
        }

        // Calculate the acceleration of an object due to gravity
        fun gravitational_acceleration(m: Float, r: Float): Float {
            return G_CONSTANT * m / (r * r);
        }
        
        // Calculate the escape velocity of an object
        fun escape_velocity(m: Float, r: Float): Float {
            return math.sqrt(2 * gravitational_acceleration(m, r) * r);
        }

        // Calculate the period of a satellite in orbit
        fun orbital_period(m: Float, r: Float): Float {
            return 2 * math.PI * math.sqrt(r * r * r / (G_CONSTANT * m));
        }

        // Calculate the angular velocity of a satellite in orbit
        fun orbital_angular_velocity(m: Float, r: Float): Float {
            return 2 * math.PI / orbital_period(m, r);
        }

        // Calculate the centripetal force of a satellite in orbit
        fun centripetal_force(m: Float, r: Float, v: Float): Float {
            return m * v * v / r;
        }

        // Calculate the centripetal acceleration of a satellite in orbit
        fun centripetal_acceleration(r: Float, v: Float): Float {
            return v * v / r;
        }

        // Calculate the tangential velocity of a satellite in orbit
        fun tangential_velocity(r: Float, v: Float): Float {
            return math.sqrt(v * v - centripetal_acceleration(r, v) * r);
        }
    }

    mod astronomy {
        from fallible import Option;

        // A module for astronomical calculations
        fun light_years_to_meters(light_years: Float): Float {
            return light_years * 9461000000000000.0;
        }

        // Calculate the apparent magnitude of a star
        fun apparent_magnitude(luminosity: Float, distance: Float): Float {
            return -2.5 * math.ln(luminosity / (4 * math.PI * distance * distance));
        }

        // Calculate the absolute magnitude of a star
        fun absolute_magnitude(apparent_magnitude: Float, distance: Float): Float {
            return apparent_magnitude - 5 * math.ln(distance / 10);
        }

        enum Planet {
            Mercury,
            Venus,
            Earth,
            Mars,
            Jupiter,
            Saturn,
            Uranus,
            Neptune,
        }

        impl Planet {
            const ORBITAL_RADII = [
                0.39,
                0.72,
                1.0,
                1.52,
                5.2,
                9.58,
                19.22,
                30.05
            ];

            const PLANETS = [
                Planet of Mercury,
                Planet of Venus,
                Planet of Earth,
                Planet of Mars,
                Planet of Jupiter,
                Planet of Saturn,
                Planet of Uranus,
                Planet of Neptune
            ];

            const ORBITAL_PERIODS = [
                0.24,
                0.62,
                1.0,
                1.88,
                11.86,
                29.46,
                84.01,
                164.8
            ];

            const POSITION_AT_EPOCH = [
                (-42278675812.454315, 24613309950.918446, 17482615609.45234),
                (-108190381646.73073, -13317243499.344467, 818212376.0610391),
                (-26004940524.516987, 132621768469.43376, 57523897417.362076),
                (-45075950705.15841, -198201555907.44907, -89682031118.63554),
                (521378228062.63275, 493060238375.3027, 198651062155.9376),
                (1344601806306.465, -493006383015.7458, -261550590693.13828),
                (1834521958762.2458, 2105690989019.717, 896288551314.5364),
                (4463253980773.344, -207488910186.74722, -196045534921.0069)
            ];

            fun orbital_radius(self): Float {
                return Planet.ORBITAL_RADII[self.order_from_sun()];
            }

            fun orbital_period(self): Float {
                return Planet.ORBITAL_PERIODS[self.order_from_sun()];
            }

            fun position_at_epoch(self): (Float, Float, Float) {
                return Planet.POSITION_AT_EPOCH[self.order_from_sun()];
            }

            fun order_from_sun(self): Int {
                match self {
                    of Mercury => 0,
                    of Venus => 1,
                    of Earth => 2,
                    of Mars => 3,
                    of Jupiter => 4,
                    of Saturn => 5,
                    of Uranus => 6,
                    of Neptune => 7
                }
            }

            fun position_at_instant(self, now: Instant): Point3D {
                let (x0, y0, z0) = self.position_at_epoch();
                
                let t = time.SECONDS_PER_YEAR;
                
                let omega = 2 * math.PI / t;
                
                let theta = omega * now.as_secs() as Float;
                
                let cos_theta = math.cos(theta);
                let sin_theta = math.sin(theta);
                
                return {
                    x=x0 * cos_theta - y0 * sin_theta,
                    y=x0 * sin_theta + y0 * cos_theta,
                    z=z0
                };
            }
        }
    }
}