mod math {
    const PI = 3.14159265358979323846;
    const TAU = 6.28318530717958647693;
    const EPSILON = 0.000001;
    const MAX_TRIG_ITERATIONS = 100;
    const MAX_SQRT_ITERATIONS = 20;
    const MAX_LOG_ITERATIONS = 200;

    fun factorial(n: Int): Int {
        if n <= 0 {
            return 1;
        }
        return n * factorial(n - 1);
    }

    impl Float {
        fun abs(self): Float {
            if self < 0.0 {
                return -self;
            }
            return self;
        }

        fun round(self): Int {
            if self < 0.0 {
                return (self - 0.5) as Int;
            }
            return (self + 0.5) as Int;
        }

        fun round_to(self, n: Int): Float {
            let mut factor = 1.0;
            for let mut i=0; i<n; i+=1; {
                factor *= 10;
            }
            return (self * factor).round() as Float / factor as Float;
        }

        fun floor(self: Float): Int {
            return self as Int;
        }

        fun ceil(self: Float): Int {
            let mut i = self as Int;
            if self > i {
                return i + 1;
            }
            return i;
        }
    }

    impl Int {
        fun abs(self): Int {
            if self < 0 {
                return -self;
            }
            return self;
        }
    }

    // Calculate the greatest common divisor of two numbers using Euclid's algorithm
    fun gcd(a: Int, b: Int): Int {
        if b == 0 {
            return a;
        }
        return gcd(b, a % b);
    }

    // Taylor series approximation of sine
    fun sin(mut x: Float): Float {
        x %= PI * 2;
        let mut result = 0.0;
        let mut term = x;
        let mut i = 1;
        while i < MAX_TRIG_ITERATIONS {
            result += term;
            term *= -x * x / (2 * i + 1) / (2 * i);
            i += 1;
        }
        return result;
    }

    // Taylor series approximation of cosine
    fun cos(x: Float): Float {
        return sin(x + PI / 2);
    }

    // Taylor series approximation of tangent
    fun tan(x: Float): Float {
        return sin(x) / cos(x);
    }

    fun asin(x: Float): Float {
        // Taylor series approximation of arcsine
        fun asin_approx(x: Float): Float {

            let x2 = x * x; // x^2
            let x4 = x2 * x2; // x^4
            let x6 = x4 * x2; // x^6
            let x8 = x6 * x2; // x^8
            let x10 = x8 * x2; // x^10
            let x12 = x10 * x2; // x^12

            return x * (1.0
                + (1.0 / 6.0) * x2
                + (3.0 / 40.0) * x4
                + (5.0 / 112.0) * x6
                + (35.0 / 1152.0) * x8
                + (63.0 / 2816.0) * x10
                + (231.0 / 13312.0) * x12);
        }

        // As x approaches 1, the series converges more slowly
        // add a condition to speed up the calculation
        if x.abs() > 0.9 {
            let complement = sqrt(1.0 - x * x);
            let result = PI / 2 - asin_approx(complement);
            if x < 0 {
                return -result;
            }
            return result;
        }

        return asin_approx(x);
    }

    // Taylor series approximation of arccosine
    fun acos(x: Float): Float {
        return PI / 2 - asin(x);
    }

    // Calculate the arctangent of a number
    fun atan(x: Float): Float {
        let x2 = x * x; // x^2
        let x3 = x2 * x; // x^3
        let x5 = x3 * x2; // x^5
        let x7 = x5 * x2; // x^7
        let x9 = x7 * x2; // x^9
        let x11 = x9 * x2; // x^11
        let x13 = x11 * x2; // x^13

        return x * (1.0
            - (1.0 / 3.0) * x2
            + (1.0 / 5.0) * x3
            - (1.0 / 7.0) * x5
            + (1.0 / 9.0) * x7
            - (1.0 / 11.0) * x9
            + (1.0 / 13.0) * x11
            - (1.0 / 15.0) * x13);
    }

    // Calculate the arctangent of a fraction
    fun atan2(y: Float, x: Float): Float {
        if x.abs() > EPSILON {
            if x.abs() > y.abs() {
                let z = y / x;
                if x > 0 {
                    return atan(z);
                } else if y > 0 {
                    return atan(z) + PI;
                } else {
                    return atan(z) - PI;
                }
            } else {
                let z = x / y;
                if y > 0 {
                    return -atan(z) + PI / 2;
                } else {
                    return -atan(z) - PI / 2;
                }
            }
        } else {
            if y > 0 {
                return PI / 2;
            } else if y < 0 {
                return -PI / 2;
            }
        }
        return 0.0;
    }

    // Calculate the square root of a number using Newton's method
    fun sqrt(x: Float): Float {
        let mut result = x;
        let mut i = 0;
        while i < MAX_SQRT_ITERATIONS && result > EPSILON {
            result = (result + x / result) / 2;
            i += 1;
        }
        return result;
    }

    // Calculate the natural logarithm of a number
    fun ln(x: Float): Float {
        let mut result = 0.0;
        let mut term = (x - 1) / (x + 1);
        let mut i = 1;
        while i < MAX_LOG_ITERATIONS {
            result += term / i;
            term *= (x - 1) * (x - 1) / (x + 1) / (x + 1);
            i += 2;
        }
        return 2 * result;
    }

    // Calculate the base 10 logarithm of a number
    fun log10(x: Float): Float {
        return ln(x) / ln(10.0);
    }

    // Calculate the exponential of a number
    fun exp(x: Float): Float {
        let mut result = 1.0;
        let mut term = 1.0;
        let mut i = 1;
        while i < MAX_TRIG_ITERATIONS {
            term *= x / i;
            result += term;
            i += 1;
        }
        return result;
    }

    // Calculate the power of a number
    fun pow(x: Float, y: Float): Float {
        return exp(y * ln(x));
    }

    // Calculate the hyperbolic sine of a number
    fun sinh(x: Float): Float {
        return (exp(x) - exp(-x)) / 2;
    }

    // Calculate the hyperbolic cosine of a number
    fun cosh(x: Float): Float {
        return (exp(x) + exp(-x)) / 2;
    }

    // Calculate the hyperbolic tangent of a number
    fun tanh(x: Float): Float {
        return sinh(x) / cosh(x);
    }

    // Calculate the hyperbolic arcsine of a number
    fun asinh(x: Float): Float {
        return ln(x + sqrt(x * x + 1));
    }

    // Calculate the hyperbolic arccosine of a number
    fun acosh(x: Float): Float {
        return ln(x + sqrt(x * x - 1));
    }

    // Calculate the hyperbolic arctangent of a number
    fun atanh(x: Float): Float {
        return ln((1 + x) / (1 - x)) / 2;
    }

    // Calculate the hyperbolic arctangent of a fraction
    fun atanh2(y: Float, x: Float): Float {
        return atanh(y / x);
    }
}

mod mem {
    // A function for allocating memory
    fun malloc<T>(n: Int): &mut T {
        return alloc(n * sizeof<T>());
    }
}

mod env {
    // A function for halting the program
    fun exit(n: Int): ! {
        // `!` is the type of a value that never returns
        println("Exit: ", n);
        debug();
        while True {}
    }
}

mod io {
    // Import from math just to test
    from math import gcd;

    // Print a character to the screen
    fun putln<T>(x: T) {
        print(x);
        print('\n');
    }

    // Get a character from input
    fun getchar(): Char {
        let mut ch = ' ';
        input(&mut ch);
        return ch;
    }

    // Add these put/get functions as methods to the Char type
    impl Char {
        fun put(&self) { putln<Char>(*self); }

        fun get(): Char { return getchar(); }
    }
}

mod fallible {
    fun panic(msg: &Char): ! {
        print("Error: ", msg);
    }

    enum Result<T, E> {
        Ok(T),
        Err(E)
    }

    impl Result<T, E> {
        fun ok(x: T): Result<T, E> {
            return Result<T, E> of Ok(x);
        }

        fun err(x: E): Result<T, E> {
            return Result<T, E> of Err(x);
        }

        fun is_ok(&self): Bool {
            match self {
                &of Ok(_) => True,
                        _ => False
            }
        }

        fun is_err(&self): Bool {
            !self.is_ok()
        }

        fun unwrap(self): T {
            match self {
                of Ok(x) => x,
                _ => panic(&"Oh no, tried to unwrap an error!")
            }
        }
    }

    enum Option<T> {
        Some(T),
        Nothing
    }

    // Add some associated functions to the Option enum
    impl Option<T> {
        fun nullify(&mut self) {
            *self = Option<T> of Nothing;
        }

        fun as_ref(&self): Option<&T> {
            let inner = self as &T;
            if let &of Nothing = self {
                return Option<&T> of Nothing;
            }
            return Option<&T> of Some(inner);
        }

        fun as_ref_mut(&mut self): Option<&mut T> {
            let inner = self as &mut T;
            if let &of Nothing = self {
                return Option<&mut T> of Nothing;
            }
            return Option<&mut T> of Some(inner);
        }

        fun print(&self) {
            match self {
                &of Some(x) => print("Some(", x, ")"),
                _ => print("Nothing")
            }
        }

        fun println(&self) {
            self.print();
            print("\n");
        }

        fun map<U>(&self, f: fun(T) -> U): Option<U> {
            match *self {
                of Some(x) => Option<U> of Some(f(x)),
                _ => Option<U> of Nothing
            }
        }

        fun is_some(&self): Bool {
            match self {
                &of Some(_) => True,
                _ => False
            }
        }

        fun is_none(&self): Bool {
            match self {
                &of Some(_) => False,
                _ => True
            }
        }

        fun unwrap(self): T {
            match self {
                of Some(x) => x,
                _ => panic(&"called `Option.unwrap()` on a `Nothing` value")
            }
        }

        fun unwrap_or(self, default: T): T {
            match self {
                of Some(x) => x,
                _ => default
            }
        }
    }

}

mod int {
    const MAX_INT = 2147483647;
    const MIN_INT = -2147483648;
}

mod collections {
    from fallible import panic, Option;
    from mem import malloc;

    enum List<T> {
        Cons(T, &List<T>),
        Nil
    }
    
    impl List<T> {
        fun new(x: T): List<T> {
            List<T> of Cons(x, new List<T> of Nil);
        }
        
        fun cons(self, value: T): List<T> {
            return List<T> of Cons(value, new self);
        }
        
        fun head(&self): T {
            match self {
                &of Cons(x, _) => x,
                _ => panic(&"Got head of empty list!")
            }
        }
        
        fun print(&self) {
            match self {
                &of Cons(head, tail) => {
                    print(head);
                    print(" ");
                    tail.print();
                },
                _ => {}
            }
        }
        
        fun println(&self) {
            self.print();
            println();
        }

        fun map<U>(self, f: fun(T) -> U): List<U> {
            match self {
                of Cons(head, tail) => tail.map<U>(f).cons(f(head)),
                _ => List<U> of Nil
            }
        }
    }


    struct Vec<T> {
        data: &mut T,
        length: Int,
        cap: Int
    }

    fun memcpy<T>(dest: &mut T, src: &T, size: Int) {
        for let mut i=0; i<size; i+=1; {
            dest[i] = src[i];
        }
    }

    impl Vec<T> {
        fun make(): Vec<T> {
            let cap = 128;
            let mut data = alloc(cap * sizeof<T>()) as &mut T;
            return {
                data=data,
                length=0,
                cap=cap
            };
        }

        fun reserve(&mut self, cap: Int) {
            if cap > self.cap {
                let mut new_data = malloc<T>(cap);
                memcpy<T>(new_data, self.data, self.length);
                free(self.data);
                self.data = new_data;
                self.cap = cap;
            }
        }

        fun push(&mut self, x: T) {
            if self.length == self.cap {
                self.reserve(self.cap * 2);
            }
            self.data[self.length] = x;
            self.length += 1;
        }

        fun pop(&mut self): Option<T> {
            if self.length == 0 {
                return Option<T> of Nothing;
            }
            self.length -= 1;
            return Option<T> of Some(self.data[self.length]);
        }

        fun clear(&mut self) {
            self.length = 0;
        }

        fun print(&self) {
            print("[");
            for let mut i=0; i < self.length; i += 1; {
                print(self.data[i]);
                if i < self.length - 1 {
                    print(", ");
                }
            }
            print("]");
        }

        fun println(&self) {
            self.print();
            print("\n");
        }

        fun get(&self, i: Int): &T {
            return &(self.data[i]);
        }

        fun get_mut(&mut self, i: Int): &mut T {
            return &mut (self.data[i]);
        }

        fun set(&mut self, i: Int, x: T) {
            self.data[i] = x;
        }

        fun nth(&self, i: Int): Option<&T> {
            if i < 0 || i >= self.length {
                return Option<&T> of Nothing;
            }
            return Option<&T> of Some(self.get(i));
        }

        fun len(&self): Int {
            return self.length;
        }

        fun map<U>(&self, f: fun(T) -> U): Vec<U> {
            let mut new_vec = Vec.make<U>();
            for let mut i=0; i < self.length; i += 1; {
                new_vec.push(f(self.data[i]));
            }
            return new_vec;
        }

        fun reduce<U>(&self, f: fun(U, T) -> U, init: U): U {
            let mut result = init;
            for let mut i=0; i<self.length; i+=1; {
                result = f(result, self.data[i]);
            }
            return result;
        }

        fun drop(&mut self) {
            free(self.data);
        }
    }

    // Hash a value
    fun hash<T>(t: T): Int {
        let size = sizeof(t);
        let ptr = (&t) as &Int;
        
        let mut hashValue = 5381;
        fun left_shift(mut a: Int, mut b: Int): Int {
            while b {
                a *= 2;
                b -= 1;
            }
            return a;
        }

        for let mut i = 0; i < size; i += 1; {
            let mut value = ptr[i];
            while (value != 0) {
                let digit = value % 10;
                hashValue = (left_shift(hashValue, 5) + hashValue) + digit;
                value /= 10;
            }
        }

        if hashValue < 0 {
            hashValue = -hashValue;
        }
        
        return hashValue;
    }
    // Compare two values for equality
    fun eq<K>(a: K, b: K): Bool {
        let size = sizeof(a);
        let a_ptr = (&a) as &Int;
        let b_ptr = (&b) as &Int;
        
        for let mut i=0; i<size; i+=1; {
            if a_ptr[i] != b_ptr[i] {
                return False;
            }
        }
        return True;
    }

    struct Entry<K, V> {
        key: K,
        value: V
    }

    struct HashMap<K, V> {
        data: Vec<Option<Entry<K, V>>>,
        occupied: Int,
    }

    impl HashMap<K, V> {
        fun make(): HashMap<K, V> {
            let mut data = Vec.make<Option<Entry<K, V>>>();
            for let mut i=0; i < 128; i += 1; {
                data.push(Option<Entry<K, V>> of Nothing);
            }
            return {
                data=data,
                occupied=0
            };
        }

        fun len(&self): Int {
            return self.occupied;
        }

        fun contains_key(&self, key: K): Bool {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    return True;
                }
                index = (index + 1) % self.data.len();
            }
            return False;
        }
        
        fun insert(&mut self, key: K, value: V) {
            if self.occupied * 2 > self.data.len() {
                for let mut i=0; i < self.occupied * 2; i += 1; {
                    self.data.push(Option<Entry<K, V>> of Nothing);
                }
            }
            let mut index = (hash<K>(key)) % (self.data.len());
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    self.data.set(index, Option<Entry<K, V>> of Some({key=key, value=value}));
                    return ();
                }
                index = (index + 1) % self.data.len();
            }
            self.data.set(index, Option<Entry<K, V>> of Some({key=key, value=value}));
            self.occupied += 1;
        }

        fun remove(&mut self, key: K) {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    self.data.set(index, Option<Entry<K, V>> of Nothing);
                    self.occupied -= 1;
                    return ();
                }
                index = (index + 1) % self.data.len();
            }
        }
        
        fun get_and_unwrap(&self, key: K): V {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    match self.data.get(index).as_ref() {
                        of Some(inner) => {
                            return inner.value;
                        },
                        _ => ()
                    }
                }
                index = (index + 1) % self.data.len();
            }
            panic(&"called `HashMap.get_and_unwrap()` on a `Nothing` value");
        }

        fun get(&self, key: K): Option<&V> {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    match self.data.get(index).as_ref() {
                        of Some(inner) => {
                            return Option<&V> of Some(&(inner.value));
                        },
                        _ => ()
                    }
                }
                index = (index + 1) % self.data.len();
            }
            return Option<&V> of Nothing;
        }

        fun get_mut(&mut self, key: K): Option<&mut V> {
            let mut index = hash<K>(key) % self.data.len();
            while self.data.get(index).is_some() {
                if eq<K>(self.data.get(index).unwrap().key, key) {
                    match self.data.get_mut(index).as_ref_mut() {
                        of Some(inner) => {
                            return Option<&mut V> of Some(&mut (inner.value));
                        },
                        _ => ()
                    }
                }
                index = (index + 1) % self.data.len();
            }
            return Option<&mut V> of Nothing;
        }

        fun print(&self) {
            print("{");
            let mut first = True;
            for let mut i=0; i < self.data.len(); i += 1; {
                if self.data.get(i).is_some() {
                    if !first {
                        print(", ");
                    }
                    print(self.data.get(i).unwrap().key);
                    print(": ");
                    print(self.data.get(i).unwrap().value);
                    first = False;
                }
            }
            print("}");
        }

        fun println(&self) {
            self.print();
            print("\n");
        }

        fun drop(&mut self) {
            self.data.drop();
        }
    }
}

mod time {
    from fallible import Option;

    const SECONDS_PER_YEAR = 31556926;
    const SECONDS_PER_DAY = 86400;
    const SECONDS_PER_HOUR = 3600;
    

    struct Duration {
        us: Int,
        start: Option<Instant>,
        end: Option<Instant>
    }

    impl Duration {
        fun from_us(micros: Int): Duration {
            return { us=micros, start=Option<Instant> of Nothing, end=Option<Instant> of Nothing };
        }

        fun from_ms(millis: Int): Duration {
            return Duration.from_us(millis * 1000);
        }

        fun from_secs(seconds: Int): Duration {
            return Duration.from_us(seconds * 1000000);
        }

        fun from_mins(minutes: Int): Duration {
            return Duration.from_secs(minutes * 60);
        }

        fun from_hours(hours: Int): Duration {
            return Duration.from_mins(hours * 60);
        }

        fun as_secs(self): Int {
            return self.us / 1000000;
        }

        fun as_years(self): Float {
            return self.us as Float / 1000000.0 / SECONDS_PER_YEAR as Float;
        }
    }

    struct Instant {
        us: Int
    }

    // Get the time since the Unix epoch in microseconds
    extern fun microseconds_since_epoch(): Int;

    impl Instant {
        // Get the current time
        fun now(): Instant {
            return { us=microseconds_since_epoch() };
        }

        fun epoch(): Instant {
            return { us=0 };
        }

        fun as_secs(self): Int {
            return self.us / 1000000;
        }

        fun from_us_since_epoch(micros: Int): Instant {
            return { us=micros };
        }

        fun time_since_epoch(self): Duration {
            return Duration.from_us(self.us);
        }

        fun elapsed(self): Duration {
            let now = Instant.now();
            return {
                us=now.us - self.us,
                start=Option<Instant> of Some(self),
                end=Option<Instant> of Some(now)
            };
        }

        fun add(mut self, duration: Duration): Instant {
            self.us += duration.us;
            return self;
        }

        fun from_date(self: Date): Instant {
            let days = self.days_since_epoch();
            
            return Instant.from_us_since_epoch(days * SECONDS_PER_DAY * 1000000)
                .add(Duration.from_hours(self.hour))
                .add(Duration.from_mins(self.minute))
                .add(Duration.from_secs(self.second));
        }
    }

    enum Weekday {
        Sunday,
        Monday,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday
    }

    impl Weekday {
        fun next(self): Weekday {
            match self {
                of Sunday => Weekday of Monday,
                of Monday => Weekday of Tuesday,
                of Tuesday => Weekday of Wednesday,
                of Wednesday => Weekday of Thursday,
                of Thursday => Weekday of Friday,
                of Friday => Weekday of Saturday,
                of Saturday => Weekday of Sunday
            }
        }

        fun to_int(self): Int {
            match self {
                of Sunday => 0,
                of Monday => 1,
                of Tuesday => 2,
                of Wednesday => 3,
                of Thursday => 4,
                of Friday => 5,
                of Saturday => 6
            }
        }

        fun is_before(self, other: Weekday): Bool {
            self.to_int() < other.to_int()
        }
    }

    struct Date {
        year: Int,
        month: Int,
        day: Int,
        hour: Int,
        minute: Int,
        second: Int
    }

    impl Date {
        fun date(year: Int, month: Int, day: Int): Date {
            return { year=year, month=month, day=day, hour=0, minute=0, second=0 };
        }

        fun weekday(self): Weekday {
            match self.days_since_epoch() % 7 {
                0 => Weekday of Thursday,
                1 => Weekday of Friday,
                2 => Weekday of Saturday,
                3 => Weekday of Sunday,
                4 => Weekday of Monday,
                5 => Weekday of Tuesday,
                6 => Weekday of Wednesday,
                _ => Weekday of Sunday
            }
        }

        fun days_since_epoch(self): Int {
            let mut days = 0;
            for let mut y=1970; y<self.year; y+=1; {
                days += 365;
                if Date.date(y, 1, 1).is_leap_year() {
                    days += 1;
                }
            }
            let mut days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            if self.is_leap_year() {
                days_in_month[1] = 29;
            }
            for let mut m=1; m<self.month; m+=1; {
                days += days_in_month[m - 1];
            }
            days += self.day - 1;
            return days;
        }

        fun days_in_month(self): Int {
            let mut days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            if self.is_leap_year() {
                days_in_month[1] = 29;
            }
            return days_in_month[self.month - 1];
        }

        fun is_leap_year(self): Bool {
            return self.year % 4 == 0 && (self.year % 100 != 0 || self.year % 400 == 0);
        }

        fun print(&self) {
            print(self.year, "-", self.month, "-", self.day);
        }
    }
}

mod physics {
    // Import from math just to test
    from time import Instant, Duration, Date, SECONDS_PER_YEAR;

    // Calculate the distance between two points
    fun distance(x1: Float, y1: Float, x2: Float, y2: Float): Float {
        return math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    struct Point3D {
        x: Float,
        y: Float,
        z: Float
    }

    impl Point3D {
        fun new(x: Float, y: Float, z: Float): Point3D {
            return { x=x, y=y, z=z };
        }

        fun convert(self, f: fun(Float) -> Float): Point3D {
            return Point3D.new(f(self.x), f(self.y), f(self.z));
        }
    }


    const G_CONSTANT = 0.000000000066743;
    mod kinematics {
        // Calculate the gravitational force between two objects
        fun gravitational_force(m1: Float, m2: Float, r: Float): Float {
            return gravitational_acceleration(m1, r) * m2;
        }

        // Calculate the acceleration of an object due to gravity
        fun gravitational_acceleration(m: Float, r: Float): Float {
            return G_CONSTANT * m / (r * r);
        }
        
        // Calculate the escape velocity of an object
        fun escape_velocity(m: Float, r: Float): Float {
            return math.sqrt(2 * gravitational_acceleration(m, r) * r);
        }

        // Calculate the period of a satellite in orbit
        fun orbital_period(m: Float, r: Float): Float {
            return 2 * math.PI * math.sqrt(r * r * r / (G_CONSTANT * m));
        }

        // Calculate the angular velocity of a satellite in orbit
        fun orbital_angular_velocity(m: Float, r: Float): Float {
            return 2 * math.PI / orbital_period(m, r);
        }

        // Calculate the centripetal force of a satellite in orbit
        fun centripetal_force(m: Float, r: Float, v: Float): Float {
            return m * v * v / r;
        }

        // Calculate the centripetal acceleration of a satellite in orbit
        fun centripetal_acceleration(r: Float, v: Float): Float {
            return v * v / r;
        }

        // Calculate the tangential velocity of a satellite in orbit
        fun tangential_velocity(r: Float, v: Float): Float {
            return math.sqrt(v * v - centripetal_acceleration(r, v) * r);
        }
    }

    fun clamp_degrees(degrees: Float): Float {
        let mut result = degrees;
        while result < 0 {
            result += 360;
        }
        while result > 360 {
            result -= 360;
        }
        return result;
    }

    fun clamp_radians(radians: Float): Float {
        let mut result = radians;
        while result < 0 {
            result += 2 * math.PI;
        }
        while result > 2 * math.PI {
            result -= 2 * math.PI;
        }
        return result;
    }

    fun rad2deg(radians: Float): Float {
        return radians * 180 / math.PI;
    }

    fun deg2rad(degrees: Float): Float {
        return degrees * math.PI / 180;
    }

    mod astronomy {
        from fallible import Option;

        // A module for astronomical calculations
        fun light_years_to_meters(light_years: Float): Float {
            return light_years * 9461000000000000.0;
        }

        // Calculate the apparent magnitude of a star
        fun apparent_magnitude(luminosity: Float, distance: Float): Float {
            return -2.5 * math.ln(luminosity / (4 * math.PI * distance * distance));
        }

        // Calculate the absolute magnitude of a star
        fun absolute_magnitude(apparent_magnitude: Float, distance: Float): Float {
            return apparent_magnitude - 5 * math.ln(distance / 10);
        }


        enum MoonPhase {
            New,
            WaxingCrescent,
            FirstQuarter,
            WaxingGibbous,
            Full,
            WaningGibbous,
            LastQuarter,
            WaningCrescent
        }

        impl MoonPhase {
            const SYNODIC_MONTH = 29.53058868;
            const EPOCH_FULL_MOON_OFFSET = 22;
            fun from_date(date: Date): MoonPhase {
                let phase_days = (date.days_since_epoch() + MoonPhase.EPOCH_FULL_MOON_OFFSET + 1.5) % MoonPhase.SYNODIC_MONTH;
                let phase_index = ((phase_days / MoonPhase.SYNODIC_MONTH) * 8.0).floor() % 8;
                match phase_index {
                    0 => MoonPhase of New,
                    1 => MoonPhase of WaxingCrescent,
                    2 => MoonPhase of FirstQuarter,
                    3 => MoonPhase of WaxingGibbous,
                    4 => MoonPhase of Full,
                    5 => MoonPhase of WaningGibbous,
                    6 => MoonPhase of LastQuarter,
                    7 => MoonPhase of WaningCrescent,
                    _ => MoonPhase of New
                }
            }

            fun print(self) {
                match self {
                    of New => print("N"),
                    of WaxingCrescent => print("W"),
                    of FirstQuarter => print("Q"),
                    of WaxingGibbous => print("G"),
                    of Full => print("F"),
                    of WaningGibbous => print("g"),
                    of LastQuarter => print("q"),
                    of WaningCrescent => print("w")
                }
            }
        }

        struct KeplerianElements {
            // Longitude of the ascending node (degrees)
            N: Float,
            // Degrees per JD2000 day
            N_dt: Float,
            // Inclination to the ecliptic (degrees)
            i: Float,
            // Degrees per JD2000 day
            i_dt: Float,
            // Argument of perihelion (degrees)
            w: Float,
            // Degrees per JD2000 day
            w_dt: Float,
            // Semi-major axis (AU)
            a: Float,
            // AU per JD2000 day
            a_dt: Float,
            // Ecentricity (unitless)
            e: Float,
            // Unitless per JD2000 day
            e_dt: Float,
            // Mean anomaly (degrees)
            M: Float,
            // Degrees per JD2000 day
            M_dt: Float,
            // Obliquity of the ecliptic (degrees)
            oblecl: Float,
            // Degrees per JD2000 day
            oblecl_dt: Float
        }

        impl KeplerianElements {
            const SUN = {
                N=0.0,
                N_dt=0.0,
                i=0.0,
                i_dt=0.0,
                w=282.9404,
                w_dt=4.70935e-5,
                a=1.000000,
                a_dt=0.0,
                e=0.01671022,
                e_dt=-1.151e-9,
                M=356.0470,
                M_dt=0.9856002585,
                oblecl=23.4393,
                oblecl_dt=-3.563e-7
            };

            const MERCURY = {
                N=48.3313,
                N_dt=3.24587e-5,
                i=7.0047,
                i_dt=5.00e-8,
                w=29.1241,
                w_dt=1.01444e-5,
                a=0.38709893,
                a_dt=0.0,
                e=0.20563593,
                e_dt=5.59e-10,
                M=168.6562,
                M_dt=4.0923344368,
                oblecl=23.4393,
                oblecl_dt=-3.563e-7
            };

            const VENUS = {
                N=76.6799,
                N_dt=2.46590e-5,
                i=3.3946,
                i_dt=2.75e-8,
                w=54.8910,
                w_dt=1.38374e-5,
                a=0.72333199,
                a_dt=0.0,
                e=0.00677323,
                e_dt=1.302e-9,
                M=48.0052,
                M_dt=1.6021302244,
                oblecl=23.4393,
                oblecl_dt=-3.563e-7
            };

            const MARS = {
                N=49.5574,
                N_dt=2.11081e-5,
                i=1.8497,
                i_dt=-1.78e-8,
                w=286.5016,
                w_dt=2.92961e-5,
                a=1.52366231,
                a_dt=0.0,
                e=0.09341233,
                e_dt=2.516e-9,
                M=18.6021,
                M_dt=0.5240207766,
                oblecl=23.4393,
                oblecl_dt=-3.563e-7
            };

            const JUPITER = {
                N=100.4542,
                N_dt=2.76854e-5,
                i=1.3030,
                i_dt=-1.557e-7,
                w=273.8777,
                w_dt=1.64505e-5,
                a=5.202603191,
                a_dt=0.0,
                e=0.04846418,
                e_dt=4.469e-9,
                M=19.8950,
                M_dt=0.0830853001,
                oblecl=23.4393,
                oblecl_dt=-3.563e-7
            };

            const SATURN = {
                N=113.6634,
                N_dt=2.38980e-5,
                i=2.4886,
                i_dt=-1.081e-7,
                w=339.3939,
                w_dt=2.97661e-5,
                a=9.554909596,
                a_dt=0.0,
                e=0.05550825,
                e_dt=-9.499e-9,
                M=316.9670,
                M_dt=0.0334442282,
                oblecl=23.4393,
                oblecl_dt=-3.563e-7
            };

            const URANUS = {
                N=74.0005,
                N_dt=1.3978e-5,
                i=0.7733,
                i_dt=1.9e-8,
                w=96.6612,
                w_dt=3.0565e-5,
                a=19.181263,
                a_dt=-1.55e-8,
                e=0.04716801,
                e_dt=-8.16e-9,
                M=142.5905,
                M_dt=0.011725806,
                oblecl=23.4393,
                oblecl_dt=-3.563e-7
            };

            const NEPTUNE = {
                N=131.7806,
                N_dt=3.0173e-5,
                i=1.7700,
                i_dt=-2.55e-7,
                w=272.8461,
                w_dt=-6.027e-6,
                a=30.05826,
                a_dt=3.313e-8,
                e=0.00860672,
                e_dt=2.15e-9,
                M=260.2471,
                M_dt=0.005995147,
                oblecl=23.4393,
                oblecl_dt=-3.563e-7
            };

            /// Account for the time elapsed since JD2000
            fun at_date(mut self, now: Date): KeplerianElements {
                fun julian_day(mut year: Int, mut month: Int, day: Int): Float {
                    if (month <= 2) {
                        year -= 1;
                        month += 12;
                    }
                    
                    let A = year / 100;
                    let B = 2 - A + (A / 4);
                    
                    return (365.25 * (year + 4716)) as Int + ((30.6001 * (month + 1)) as Int) + day + B - 1524.5;
                }

                fun date_to_jd2000(now: Date): Float {
                    let Y = now.year as Float;
                    let M = now.month as Float;
                    let D = now.day as Float;
                    return julian_day(now.year, now.month, now.day) - 2451543;
                }

                let d = date_to_jd2000(now);

                self.N = clamp_degrees(self.N + self.N_dt * d);
                self.i = self.i + self.i_dt * d;
                self.w = self.w + self.w_dt * d;
                self.a = self.a + self.a_dt * d;
                self.e = self.e + self.e_dt * d;
                self.M = clamp_degrees(self.M + self.M_dt * d);
                self.oblecl = self.oblecl + self.oblecl_dt * d;

                self
            }

            fun distance_and_true_anomaly(mut self, now: Date): (Float, Float) {
                self = self.at_date(now);
                let M = clamp_degrees(self.M);
                let oblecl = self.oblecl;
                let e = M + rad2deg(self.e) * math.sin(deg2rad(M)) * (1.0 + self.e * math.cos(deg2rad(M)));
                let x = self.a * (math.cos(deg2rad(e)) - self.e);
                let tmp = math.sqrt(1.0 - self.e * self.e);
                let y = self.a * tmp * math.sin(deg2rad(e));
                let r = math.sqrt(x * x + y * y);
                let v = clamp_degrees(rad2deg(math.atan2(y, x)));

                return (r, v);
            }

            // Get the position of the celestial body on a given date
            // in the heliocentric ecliptic coordinate system.
            fun position_on_date(mut self, now: Date): Point3D {
                let (r, v) = self.distance_and_true_anomaly(now);

                let oblecl = self.oblecl;
                let lon = clamp_degrees(v + self.w);
                
                let xh = r * (math.cos(deg2rad(lon)) * math.cos(deg2rad(self.N)) - math.sin(deg2rad(lon)) * math.sin(deg2rad(self.N)) * math.cos(deg2rad(self.i)));
                let yh = r * (math.sin(deg2rad(lon)) * math.cos(deg2rad(self.N)) + math.cos(deg2rad(lon)) * math.sin(deg2rad(self.N)) * math.cos(deg2rad(self.i)));
                let zh = r * (math.sin(deg2rad(self.i)) * math.sin(deg2rad(lon)));

                let xe = xh;
                let ye = yh * math.cos(deg2rad(oblecl)) - zh * math.sin(deg2rad(oblecl));
                let ze = yh * math.sin(deg2rad(oblecl)) + zh * math.cos(deg2rad(oblecl));

                return Point3D.new(xe, ye, ze);
            }
        }

        enum Planet {
            Mercury,
            Venus,
            Earth,
            Mars,
            Jupiter,
            Saturn,
            Uranus,
            Neptune,
        }

        impl Planet {
            const ORBITAL_RADII_AU = [
                0.39,
                0.72,
                1.0,
                1.52,
                5.2,
                9.58,
                19.22,
                30.05
            ];
            const ORBITAL_RADII_METERS = [
                57909050000.0,
                108208930000.0,
                149597870700.0,
                227936640000.0,
                778412010000.0,
                1426725400000.0,
                2870972200000.0,
                4498252900000.0
            ];

            const PLANETS = [
                Planet of Mercury,
                Planet of Venus,
                Planet of Earth,
                Planet of Mars,
                Planet of Jupiter,
                Planet of Saturn,
                Planet of Uranus,
                Planet of Neptune
            ];

            const ORBITAL_PERIODS = [
                0.24,
                0.62,
                1.0,
                1.88,
                11.86,
                29.46,
                84.01,
                164.8
            ];

            // Orbital radius in AU
            fun orbital_radius(self): Float {
                return Planet.ORBITAL_RADII_AU[self.order_from_sun()];
            }

            fun orbital_period(self): Float {
                return Planet.ORBITAL_PERIODS[self.order_from_sun()];
            }

            /// Get the radius of the planet in AU.
            fun radius(self): Float {
                (match self {
                    of Mercury => 2439700.0,
                    of Venus => 6051800.0,
                    of Earth => 6371000.0,
                    of Mars => 3389500.0,
                    of Jupiter => 69911000.0,
                    of Saturn => 58232000.0,
                    of Uranus => 25362000.0,
                    of Neptune => 24622000.0
                }) / 149597870700.0
            }

            // Get the keplerian elements associated with the
            // celestial body.
            fun keplerian_elements(self): KeplerianElements {
                match self {
                    of Mercury => KeplerianElements.MERCURY,
                    of Venus => KeplerianElements.VENUS,
                    of Earth => KeplerianElements.SUN,
                    of Mars => KeplerianElements.MARS,
                    of Jupiter => KeplerianElements.JUPITER,
                    of Saturn => KeplerianElements.SATURN,
                    of Uranus => KeplerianElements.URANUS,
                    of Neptune => KeplerianElements.NEPTUNE
                }
            }

            // Get the order of the planet from the sun
            fun order_from_sun(self): Int {
                match self {
                    of Mercury => 0,
                    of Venus => 1,
                    of Earth => 2,
                    of Mars => 3,
                    of Jupiter => 4,
                    of Saturn => 5,
                    of Uranus => 6,
                    of Neptune => 7
                }
            }

            // Get the position on date, in AU
            // This is heliocentric ecliptic coordinates.
            fun position_on_date(self, date: Date): Point3D {
                let elements = self.keplerian_elements();
                fun negate(p: Float): Float {
                    return -p;
                }
                if let of Earth = self {
                    return elements.position_on_date(date).convert(negate);
                }
                return elements.position_on_date(date);
            }

            fun print(self) {
                match self {
                    of Mercury => print("Mercury"),
                    of Venus => print("Venus"),
                    of Earth => print("Earth"),
                    of Mars => print("Mars"),
                    of Jupiter => print("Jupiter"),
                    of Saturn => print("Saturn"),
                    of Uranus => print("Uranus"),
                    of Neptune => print("Neptune")
                }
            }
        }
    }
}